# -*- coding: utf-8 -*-
"""stock_agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oDDnDVk5TN4byt5d_0CNvz4TzLPwXxNu
"""

!pip install Wikipedia-API
!pip install newsapi-python
!pip install vaderSentiment
!pip install schedule==1.2.0
!pip install nltk
!pip install yfinance

import re
import os
import time
import yaml
from typing import Optional, Dict, List, Any
from newsapi import NewsApiClient
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
import schedule
import google.generativeai as genai
from nltk.tokenize import sent_tokenize
import nltk
from datetime import datetime
import yfinance as yf


nltk.download('punkt_tab')

class ChatBot:
    action_re = re.compile(r'^Action: (\w+): (.*)')

    def __init__(self, api_key: str, newsapi_key: Optional[str] = None, system: Optional[str] = None):
        self.api_keys = {
            "generative_ai": api_key,
            "newsapi_key": newsapi_key,
        }
        self.system = system or "You are a helpful assistant."
        self.messages = [{"role": "system", "content": self.system}]
        self.knowledge_base: Dict[str, str] = {}
        self.interaction_memory = []

        if newsapi_key:
            try:
                self.newsapi = NewsApiClient(api_key=newsapi_key)
            except Exception as e:
                print(f"Failed to initialize NewsAPI: {e}")
                self.newsapi = None

    # Method to get relevant business news from News API
    def get_news(self, query: str, category='business', language: str = 'en', sort_by: str = 'relevancy', sources: Optional[str] = None, **kwargs) -> List[Dict[str, Any]]:
        if not self.newsapi:
            return [{"error": "NewsAPI not initialized. Please provide a valid API key."}]

        try:
            articles = self.newsapi.get_everything(
                q=query,
                language=language,
                sort_by=sort_by,
                sources=sources,
                page_size=kwargs.get('page_size', 10),
                page=kwargs.get('page', 1),
                from_param=kwargs.get('from_param', None),
                to=kwargs.get('to', None),
            )
            return articles['articles']
        except Exception as e:
            return [{"error": f"Failed to fetch news: {str(e)}"}]

    # Method to load the data file to update it with new data
    def load_data(self, file_name: str = "data.yaml") -> Dict:
        if os.path.exists(file_name):
            with open(file_name, "r") as file:
                return yaml.safe_load(file) or {}
        return {}

    # Method to save the data file to update it with new data
    def save_data(self, data: Dict, file_name: str = "data.yaml") -> None:
        with open(file_name, "w") as file:
            yaml.dump(data, file)

    def analyze_sentiment(self, text: str) -> Dict[str, Any]:
        analyzer = SentimentIntensityAnalyzer()
        scores = analyzer.polarity_scores(text)

        # Extract the most sentiment-rich sentence
        sentences = sent_tokenize(text)
        sentiment_sentences = sorted(
            sentences,
            key=lambda s: abs(analyzer.polarity_scores(s)["compound"]),
            reverse=True
        )
        top_reason = sentiment_sentences[0] if sentiment_sentences else ""

        sentiment = self.classify_sentiment(scores["compound"])
        return {
            "sentiment": sentiment,
            "scores": scores,
            "reason": top_reason
        }

    def classify_sentiment(self, compound_score: float) -> str:
        if compound_score >= 0.05:
            return "Positive"
        elif compound_score <= -0.01:
            return "Negative"
        else:
            return "Neutral"

    def handle_stock_request(self, stock: str) -> str:
        # Fetch news
        articles = self.get_news(query=stock, language="en", sort_by="relevancy", page_size=10,
                                 to='2024-12-01')
        if "error" in articles[0]:
            return f"Error fetching news: {articles[0]['error']}"

        # Analyze sentiment
        sentiments = []
        reasons = []
        for article in articles:
            title = article.get("title", "")
            description = article.get("description", "")
            combined_text = f"{title}. {description}"
            sentiment_analysis = self.analyze_sentiment(combined_text)
            sentiments.append({
                "title": title,
                "description": description,
                "analysis": sentiment_analysis,
            })
            reasons.append(sentiment_analysis["reason"])

        try:
          stock_data = yf.Ticker(stock)
          current_price = stock_data.info.get("currentPrice")
        except Exception as e:
          print(f"Error fetching stock price: {e}")
          current_price = None

        # Calculate an overall sentiment score
        compound_scores = [article["analysis"]["scores"]["compound"] for article in sentiments]
        avg_score = sum(compound_scores) / len(compound_scores) if compound_scores else 0
        overall_sentiment = self.classify_sentiment(avg_score)

        # Predict price movement
        price_prediction = self.predict_price_movement(avg_score)

        # Present summary to user
        reasons_summary = "\n".join(f"- {reason}" for reason in reasons if reason)
        summary = (
            f"Analyzed sentiment for {stock}:\n"
            f"Average Sentiment Score: {avg_score:.2f} ({overall_sentiment})\n\n"
            f"Current Price: {current_price}\n"
            f"Reasons for sentiment:\n{reasons_summary}\n\n"
            f"Predicted Price Movement: {price_prediction}\n"
            f"Would you like to track {stock} daily? (yes/no): "
        )
        user_input = input(summary).strip().lower()

        if user_input == "yes":
            # Load existing data
            current_data = self.load_data()
            # Store the new stock data
            current_data[stock] = {
                "sentiment_summary": {"score": avg_score, "sentiment": overall_sentiment},
                "articles": sentiments,
                "reasons": reasons,
                "current_price": current_price,
                "price_history": {str(datetime.now().date()): current_price},
                "tracking_since": str(datetime.now().date()),
                "price_prediction": price_prediction
            }
            self.save_data(current_data)
            self.schedule_updates(stock)
            correlation_result = self.analyze_price_sentiment_correlation(stock)
            print(correlation_result)
            return f"Tracking {stock} daily... {correlation_result}"
            return f"Tracking {stock} daily. Data has been saved and updates scheduled."
        else:
            return f"Sentiment analysis for {stock} completed. Tracking not enabled."

    # Method to analyze the correlation between price and sentiment
    def analyze_price_sentiment_correlation(self, stock: str):
        data = self.load_data()
        price_history = data.get(stock, {}).get("price_history", {})

        if len(price_history) < 2:
            return "Not enough price history to analyze."

        prices = list(price_history.values())
        dates = list(price_history.keys())

        #Compare yesterday's and today's price/sentiment
        yesterday_price = prices[-2]
        today_price = prices[-1]
        price_change = today_price - yesterday_price

        yesterday_sentiment = data.get(stock, {}).get("sentiment_summary", {}).get("sentiment", "Unknown")

        if price_change > 0 and yesterday_sentiment == "Positive":
            correlation = "Positive sentiment may have influenced the price increase."
        elif price_change < 0 and yesterday_sentiment == "Negative":
            correlation = "Negative sentiment may have influenced the price decrease."
        else:
            correlation = "No clear correlation between sentiment and price change."

        return f"Price Change: {price_change:.2f} ({dates[-2]} to {dates[-1]})\nPrevious Day's Sentiment: {yesterday_sentiment}\nCorrelation: {correlation}"

    # Method to predict price movement
    def predict_price_movement(self, sentiment_score: float) -> str:
        """Predicts stock price movement based on sentiment score."""
        if sentiment_score >= 0.2:
            return "Increase"
        elif sentiment_score <= -0.2:
            return "Decrease"
        else:
            return "Neutral/Uncertain"

    # Method to schedule the agent to run daily
    def schedule_updates(self, stock: str):
        def update_stock_news():
            print(f"Updating news and sentiment analysis for {stock}...")
            self.handle_stock_request(stock)

            try:
              current_price = stock_data.info.get("currentPrice")
              current_data[stock]["price_history"][str(datetime.now().date())] = current_price
              self.save_data(current_data)
            except Exception as e:
              print(f"Error fetching/storing stock price: {e}")


        schedule.every().day.at("22:44").do(update_stock_news)
        print(f"Scheduled daily updates for {stock} at 22:44.")
        while True:
            schedule.run_pending()
            time.sleep(28800)

# api_key is where the Gemini API key goes
# newsapi_key is where the News API key goes

if __name__ == "__main__":
    bot = ChatBot(api_key="", newsapi_key="")
    user_stock = input("Enter a stock ticker to analyze (e.g. TSLA): ")
    response = bot.handle_stock_request(user_stock)
    print(response)